---
description: 
globs: 
alwaysApply: true
---
# Regra de MemoizaÃ§Ã£o React

## ğŸš¨ CRÃTICO: PrevenÃ§Ã£o de Re-renders Infinitos

### CenÃ¡rios que SEMPRE exigem atenÃ§Ã£o:

#### 1. **useEffect com FunÃ§Ãµes como DependÃªncias**
```typescript
// âŒ PROBLEMÃTICO - FunÃ§Ã£o recriada a cada render
const { isInstructor } = useAuth()
useEffect(() => {
  if (isInstructor()) { /* ... */ }
}, [currentEtapa, isInstructor]) // isInstructor causa loop!

// âœ… CORRETO - Chamar dentro do useEffect
useEffect(() => {
  if (isInstructor()) { /* ... */ }
}, [currentEtapa]) // Remover funÃ§Ã£o das dependÃªncias

// âœ… ALTERNATIVA - Memoizar o valor
const isInstructorMemo = useMemo(() => isInstructor(), [isInstructor, teamName, isAuthenticated])
```

#### 2. **Objetos/Arrays como DependÃªncias**
```typescript
// âŒ PROBLEMÃTICO - Novo objeto a cada render
const config = { apiUrl: '/api', retries: 3 }
useEffect(() => {
  fetchData(config)
}, [config]) // config sempre novo!

// âœ… CORRETO - useMemo para estabilizar
const config = useMemo(() => ({ 
  apiUrl: '/api', 
  retries: 3 
}), [])
```

#### 3. **Callbacks Inline em useEffect**
```typescript
// âŒ PROBLEMÃTICO - Callback recriado
useEffect(() => {
  const callback = () => { /* ... */ }
  api.subscribe(callback)
  return () => api.unsubscribe(callback)
}, [dependency])

// âœ… CORRETO - useCallback para estabilizar
const callback = useCallback(() => { /* ... */ }, [])
useEffect(() => {
  api.subscribe(callback)
  return () => api.unsubscribe(callback)
}, [callback])
```

### ğŸ” **Checklist de VerificaÃ§Ã£o OBRIGATÃ“RIA**

Antes de cada commit, verificar:

- [ ] **useEffect**: Todas as dependÃªncias sÃ£o primitivas ou memoizadas?
- [ ] **FunÃ§Ãµes**: SÃ£o estÃ¡veis (useCallback) ou chamadas dentro do useEffect?
- [ ] **Objetos/Arrays**: SÃ£o memoizados com useMemo ou useState?
- [ ] **Custom Hooks**: Retornam valores estÃ¡veis?

### ğŸ›  **Ferramentas de Debug**

```typescript
// Adicionar temporariamente para debug
useEffect(() => {
  console.log('ğŸ”¥ useEffect executou:', {
    currentEtapa: currentEtapa?.etapa.id,
    teamName,
    isAuthenticated,
    timestamp: Date.now()
  })
}, [currentEtapa, teamName, isAuthenticated])
```

### âš¡ **PadrÃµes Seguros**

#### Hook personalizado estÃ¡vel:
```typescript
export function useStableValue<T>(value: T, deps: any[]): T {
  return useMemo(() => value, deps)
}

// Uso:
const stableConfig = useStableValue({ api: '/endpoint' }, [])
```

#### Seletor otimizado para Zustand:
```typescript
const currentData = useStore(
  useCallback(
    (state) => stepId ? state.data[stepId] : undefined,
    [stepId]
  )
)
```

### ğŸš¨ **Sinais de Alerta**

1. **Componente pisca/flicker**
2. **Requests HTTP repetidos**
3. **Console.log executando infinitamente**
4. **Performance degradada**
5. **React DevTools mostrando muitos re-renders**

### ğŸ“‹ **AÃ§Ã£o Imediata ao Detectar Problema**

1. **Identificar o useEffect problemÃ¡tico**
2. **Verificar as dependÃªncias uma por uma**
3. **Memoizar ou remover dependÃªncias instÃ¡veis**
4. **Testar no navegador**
5. **Confirmar que nÃ£o hÃ¡ mais loops**

---

**Esta regra deve ser aplicada SEMPRE que:**
- Criar novos useEffect
- Modificar dependÃªncias existentes  
- Integrar com hooks customizados
- Trabalhar com dados complexos (objetos/arrays)
- Notar problemas de performance

**Lembre-se: Prevenir Ã© melhor que corrigir! ğŸ¯**

